#include <iostream>
#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>

namespace py = pybind11;
using namespace pybind11::literals;

#include "osqp_api_functions.h"
#include "osqp_api_types.h"
#include "{{prefix}}workspace.h"

py::tuple solve() {
    py::gil_scoped_release release;
    c_int status = osqp_solve(&{{prefix}}solver);
    py::gil_scoped_acquire acquire;

    if (status != 0) throw std::runtime_error("Solve failed");

    c_int m;
    c_int n;
    osqp_get_dimensions(&{{prefix}}solver, &m, &n);

    auto x = py::array_t<c_float>({n}, {sizeof(c_float)}, (&{{prefix}}solver)->solution->x);
    auto y = py::array_t<c_float>({m}, {sizeof(c_float)}, (&{{prefix}}solver)->solution->y);

    py::tuple results = py::make_tuple(x, y, status, (&{{prefix}}solver)->info->iter, (&{{prefix}}solver)->info->run_time);
    return results;
}

c_int update_data_vec(py::object q, py::object l, py::object u) {
    c_float* _q;
    c_float* _l;
    c_float* _u;

    if (q.is_none()) {
        _q = NULL;
    } else {
        _q = (c_float *)py::array_t<c_float>(q).data();
    }
    if (l.is_none()) {
        _l = NULL;
    } else {
        _l = (c_float *)py::array_t<c_float>(l).data();
    }
    if (u.is_none()) {
        _u = NULL;
    } else {
        _u = (c_float *)py::array_t<c_float>(u).data();
    }

    return osqp_update_data_vec(&{{prefix}}solver, _q, _l, _u);
}

#if EMBEDDED == 2
c_int update_data_mat(py::object P_x, py::object P_i, py::object A_x, py::object A_i) {
    c_float* _P_x;
    c_int* _P_i;
    c_int _P_n = 0;
    c_float* _A_x;
    c_int* _A_i;
    c_int _A_n = 0;

    if (P_x.is_none()) {
        _P_x = NULL;
    } else {
        auto _P_x_array = py::array_t<c_float>(P_x);
        _P_x = (c_float *)_P_x_array.data();
        _P_n = _P_x_array.size();
    }

    if (P_i.is_none()) {
        _P_i = NULL;
    } else {
        auto _P_i_array = py::array_t<c_int>(P_i);
        _P_i = (c_int *)_P_i_array.data();
        _P_n = _P_i_array.size();
    }

    if (A_x.is_none()) {
        _A_x = NULL;
    } else {
        auto _A_x_array = py::array_t<c_float>(A_x);
        _A_x = (c_float *)_A_x_array.data();
        _A_n = _A_x_array.size();
    }

    if (A_i.is_none()) {
        _A_i = NULL;
    } else {
        auto _A_i_array = py::array_t<c_int>(A_i);
        _A_i = (c_int *)_A_i_array.data();
        _A_n = _A_i_array.size();
    }

    return osqp_update_data_mat(&{{prefix}}solver, _P_x, _P_i, _P_n, _A_x, _A_i, _A_n);
}
#endif

PYBIND11_MODULE({{extension_name}}, m) {
    m.def("solve", &solve);
    m.def("update_data_vec", &update_data_vec, "Update q/l/u", py::arg("q") = py::none(), py::arg("l") = py::none(), py::arg("u") = py::none());
#if EMBEDDED == 2
    m.def("update_data_mat", &update_data_mat, "Update P/A", py::arg("P_x") = py::none(), py::arg("P_i") = py::none(), py::arg("A_x") = py::none(), py::arg("A_i") = py::none());
#endif
}
